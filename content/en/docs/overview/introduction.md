---
title: "Introduction"
description: ""
lead: ""
date: 2020-10-06T08:48:57+00:00
lastmod: 2020-10-06T08:48:57+00:00
draft: false
images: []
menu:
  docs:
    parent: "overview"
weight: 100
toc: true
---

## What is ArtifactDB?

At its heart, ArtifactDB is a file storage system with searchable metadata, versioning, and access control.
It was initially developed to manage data and results generated by genomics workflows inside Genentech,
but can be generally used to store any arbitrary file and its associated metadata.
Users can then search this metadata for interesting files and, once found, download them for further analysis.
So, if you've got some files, and they have some metadata, you can store them inside an ArtifactDB deployment.

## Features

- Flexible storage of arbitrary files and accompanying metadata.
- Customization and enforcement of metadata standards via schemas.
- High-performance search on metadata fields.
- Cloud-native implementation for scalability and accessibility.
- Versioning and immutability of files for reproducibility.
- Fine-grained access control for public and private resources.
- Extensible clients providing analysis-ready data structures.

## Key concepts

An ArtifactDB _project_ is just a grouping of related files.
The nature of this grouping is application-specific;
for example, one ArtifactDB deployment may define the outputs of an analysis pipeline as a single project,
while another deployment may consider a project to contain all files associated with a published study.

Each project may have one or more _versions_, e.g., corresponding to different analysis runs.
Different versions of the same project may share some, all or no files;
the choice between creating a new version of a project (as opposed to a new project altogether) is again application-specific.

A given version of a project will contain one or more _files_.
Each file is defined by its "path" inside the project, i.e., the relative file path if the project is treated as a directory.
Each application may apply its own constraints on the expected format and contents of each file.

Finally, each file has some accompanying _metadata_ in the form of a JSON document.
Each JSON document specifies a schema that can be used for its validation.
Applications should define a set of supported schemas, which defines the type of files that can be uploaded and their expected metadata standards.
